# ArkTS Runtime FAQs
<!--Kit: ArkTS-->
<!--Subsystem: ArkCompiler-->
<!--Owner: @DaiHuina1997-->
<!--Designer: @yao_dashuai-->
<!--Tester: @kirl75; @zsw_zhushiwei-->
<!--Adviser: @foryourself-->

## Unexpected Outputs in Ark Regular Expressions

Ark regular expressions may produce unexpected results in the following scenarios.

### Inconsistent \b Handling

   ```ts
   let str = "\u2642";
   let res = str.replace(/\b/g, "/");
   console.info("res = " + res);
   // Expected output: res = ♂
   // Actual output: res = /♂/
   ```

   Workaround: None.
   > **NOTE**
   > 
   > When regular expressions match \b (word boundaries), certain non-ASCII characters are incorrectly treated as ASCII characters, causing non-word boundaries to be mistakenly identified as word boundaries.

### Unexpected Output with Lookaheads ((?=pattern) or (?!pattern)) Nested in Lookbehinds ((?<=pattern) or (?<!pattern))

   ```ts
   console.info(`res:${"abcdef".match(/(?<=ab(?=c)cd)ef/)}`);
   // Expected output: res:ef
   // Actual output: res:null
   ```

   Workaround: Replace /(?<=ab(?=c)cd)ef/ with /(?<=abcd)ef/.

### Inconsistent Case Handling

   ```ts
   let res = /\u{10400}/ui.test("\u{10428}");
   console.info("res = " + res);
   // Expected output: res = true
   // Actual output: res = false
   ```

   Workaround: None.

### Unexpected Output of lastIndex in /()/ug

   ```ts
   let L = "\ud800";
   let T = "\udc00";
   let u = /()/ug;
   u.lastIndex = 1;
   u.exec(L + T + L + T);
   console.info("u.lastIndex = " + u.lastIndex);
   // Expected output: u.lastIndex = 0
   // Actual output: u.lastIndex = 1
   ```

   Workaround: None.

### Unexpected Output of '-' in []

   ```ts
   let str =  "a-b";
   let reg = /[+-\s]/;
   console.info("reg.exec(str) = " + reg.exec(str));
   // Expected output: reg.exec(str) = -
   // Actual output: reg.exec(str) = null
   ```

   Workaround: Use the escaped hyphen (-).
   ```ts
   let str =  "a-b";
   let reg = /[+\-\s]/;
   console.info("reg.exec(str) = " + reg.exec(str));
   ```

### Unexpected Output of Named Capture Groups

   ```ts
   let reg = new RegExp("(a)(?<b>b)");
   let res = reg.exec("ab");
   console.info("JSON.stringify(res?.groups) = " + JSON.stringify(res?.groups));
   // Expected output: JSON.stringify(res?.groups) = {"b":"b"}
   // Actual output: JSON.stringify(res?.groups) = {"b":"a"}
   ```

   Workaround: Calculate the position of the named capture group to retrieve its matched content.

   ```ts
   let reg = new RegExp("(a)(?<b>b)");
   let res = reg.exec("ab") as Array<string>;
   console.info(JSON.stringify(res[2]));
   ```

### Unexpected Output with '|' Preceded by Empty Match

   When regular expression matching is used, if the character before '|' is empty, the matching after '|' fails.

   ```ts
   let reg = /a(?:|x)$/;
   let res = reg.exec("ax");
   console.info("JSON.stringify(res) = " + JSON.stringify(res));
   // Expected output: JSON.stringify(res) = ["ax"]
   // Actual output: JSON.stringify(res) = null
   ```

   Workaround: Replace reg1 with reg2 or reg3.

   ```ts
   let reg1 = /a(?:|x)$/;
   let reg2 = /a(?:x)?$/;
   let reg3 = /a(?:x){0,1}$/;
   ```

### Unexpected Output of `replace` with Empty String as First Parameter

   When the **replace** API is used, if the first parameter is an empty string, the original string is returned.

   ```ts
   let str = "dddd"
   let res = str.replace("", "abc");
   console.info("res = " + res);
   // Expected output: res = abcdddd
   // Actual output: res = dddd
   ```

   Workaround: Use the regular expression `/^/` to indicate the start of the string as the first parameter.

   ```ts
   let str = "dddd"
   let res = str.replace(/^/, "abc");
   ```

## Exception Handling in Async Functions

**Scenario**

In ArkTS, uncaught exceptions within the **Async** function do not terminate the process. This occurs because the function returns a rejected Promise that remains unhandled, converting the internal exception into an **unhandledRejection** that is not actually thrown.

**How to Capture Exceptions**

1. Use [errorManager.on()](../reference/apis-ability-kit/js-apis-app-ability-errorManager.md#errormanageronerror) to capture the **unhandledrejection** event generated by the **Async** function, and handle the exception via the callback function registered with **errorManager.on()**.

   ```ts
      errorManager.on("unhandledRejection", (a:ESObject, b:Promise<ESObject>) => {
         console.info("Async test", a);
      })
   ```

2. Within the **Async** function, add the **try-catch** logic to code blocks that may throw exceptions to directly catch potential errors.

> **NOTE**
> 
> The **try-catch** logic must be implemented within the **Async** function. Exceptions arising internally cannot be caught from outside; they can only be listened for via **errorManager.on()**.


**How to Check Exceptions**

To check whether an exception occurs inside the **Async** function, run the following hilog command in DevEco Studio to enable debug-level log printing:

```shell
   hilog -b D
```

Click the lower **HiLog** tab and enter the filter criteria **Throw error:** to view the exception information.
![alt text](figures/arkts-runtime-faq.png)

## Array.flatMap() Issues

When the **Array.flatMap()** API is used to process an array that contains proxies, the nested proxy array is not flattened correctly, resulting in unexpected return values.

### ArkTS Scenario

```ts
let arr1 = [0, 1];
let arr2 = [2, 3];
const emptyHandler = new Object() as ProxyHandler<number[]>;
let proxy1 = new Proxy(arr1, emptyHandler);
let proxy2 = new Proxy(arr2, emptyHandler);
let arr3 = [proxy1, proxy2];
let res = arr3.flatMap(x => x);

console.log("res length:", res.length.toString());
// Expected output: res length: 4
// Actual output: res length: 2
console.log("res[0] is: ", res[0].toString());
// Expected output: res[0] is: 0
// Actual output: res[0] is: 0,1
```

### ArkUI Scenario

The ArkUI state management framework adds a proxy to arrays decorated with state variable decorators (such as @State, @Trace, and @Local) to observe changes caused by API calls. If state decorators are used with arrays and **Array.flatMap** is called, the following problem occurs.

Take state management V2 as an example:

```ts
@Entry
@ComponentV2
struct Index {
   @Local p: number[] = [0, 1];
   @Local q: number[] = [2, 3];
   c: number[][] = [this.p, this.q];
   d: number[] = [];

   aboutToAppear(): void {
      this.d = this.c.flatMap(it => it);
   }

   build() {
      Column() {
         Text(`${this.d[0]}`); // Expected output: 0; Actual output: 0,1
      }
   }
}
```

### Workaround

Avoid using the **Array.flatMap()** API. Instead, call **Array.map()** and then call the **Array.flat()** API with the depth of 1. The preceding ArkTS scenario is used as an example:

```ts
// Before workaround
let res = arr3.flatMap(x => x);
// After workaround
let res = arr3.map(x => x).flat();
```
